# 编译器与解释器
　　解释器(每次都要重新解释) ,运行速度较低,跨平台,因为代码本身就是可执行,但是不同平台下,各个解释器就是告诉平台,这个代码是怎样执行的,一边翻译,一边执行
![解释器](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525005904.png)
　　编译器(一次编译成机器码,节省重复编译)-->在该平台下运行,不跨平台
![编译器的优缺点](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525005744.png)
　　问题分解，unicode--2个字节比较常用
# 解释器原理
　　解释器原理:堆栈,程序在执行的时候,,需要把某些事暂时不做,,等到后面符合条件才做,用堆栈最合适不过
```
def compare(x,y)
```
　　compare方法先放入堆栈,此时直接运行compare方法不行,因为没有参数,我们需要把x,y依次存入堆栈,之后依次取出y,x,compare 最后进行比较,
![计算过程](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525005452.png)
　　print--没有返回值,但会返回特殊返回值--unset(本不应该有返回值的含义),之后输出之后,屏幕清空
　　堆栈两个值---返回最上面--段落换行--因为两个值的计算,相互独立,具体如下:
![堆栈两个值](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525004851.png)
![接收最上面的返回值](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525005211.png)
# 语法语义
## 值和值之间的空隙
　　值和值:一切都是用空白隔开,空白符:空格,回车,制表符(四个空格)--88--为了容易阅读,便于区分
　　代码排版的原则:段落对齐,意义对齐,缩进表示包含/接续
```
#说明没有写完--单独构建匿名函数
0==True(
pass
)
```
## 字面值
　unset:表示的是根本不应该有值
　none:可以表示有值,但是现在没值
　字面值就是存储的内容--list,tuple,int,string--直接值--内容的本身
## 函数返回值(间接值)
　无法用字面表达的类型,他们的值无法写在代码之中,,并代码无法呈现这些值,只是计算过程的产物--例如函数
　间接值--内容所对应的内存地址(编号)--让数据共享--当数据很大的时候,使用此种方式可以节省内存.
## 路径绑定
　作用:根据不同的文件名执行不同操作(例如对不同文件操作保存操作结果为对应文件名)
## 代码处理
　载入数据--代码读入,切割,绑定好并放进内存
　执行代码---把代码放进和取出堆栈
## 函数计算
　函数一定有返回值--(普通返回值,特殊返回值Unset),不管什么返回值都会在堆栈中占用空间
　解释器执行计算的时候,会偷窥下一个值是不是op!,也就是运算符的具体形式(+-*/&之类的).图片如下:
![](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525004618.png)
　每个op都有对应的函数式形式,尽量使用op的形式
　类型决定行为模式--例如上面的op运算过程
## 执行次序
　顺序,分支,循环,只要条件计算的结果不为None或者false,都认为条件成立
　一旦遇到失败就返回None,后面的程序就不计算了,说明程序会短路,不健壮
## 模块与架构
　import函数就是用来导入模块的,他的返回值就是对应模块(重点)
![](https://blog-1-1256491104.cos.ap-chengdu.myqcloud.com/20190525004112.png)
　模块的好处:代码容易维护;信息适当被隐藏

