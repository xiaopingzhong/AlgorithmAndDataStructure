# 哈希表
## 出现原因
为了同时实现快速查找和删除
数组:查找复杂度为O(1),因为根据下标就可以找到对应值
链表(循环双向链表):删除的时候,我们只需要直接将待删除节点的前后两个节点直接建立连接即可.
## 原理
哈希表:就是一个数组
哈希函数:以取模的哈希函数为例,其中key都为整数:`765, 431, 96, 142, 579, 226, 903, 388` 
```
# M为哈希表的容量大小
#为了说明哈希原理,我们设置key就是要存储的值
H(key)=key%M
```
(1)通过哈希函数给每个值对应的逻辑下标,之后根据逻辑下标,将其存储在哈希表,之后进行快速访问
(2)但是哈希表容量有限,值之间的逻辑下标会重复,就出现了哈希冲突

## 冲突解决方法
### 链接法
   (1)原理:将哈希表当中的有冲突的槽位变成链式结构,也就是说有冲突的位置,用链表作为元素,从头结点插入冲突的key
   (2)缺点:
        (2.1)当哈希函数选择不当,导致某个逻辑下标重复的次数过多,导致冲入冲突位置的链表长度过长,导致链表的长度过长,查找的复杂度可能就不是O(1)
        (2.2)由于逻辑下标的重复出现,导致数据集中存储在某一个位置,造成哈希表利用率不高--开放寻址法应用而生

### 开放寻址法
(1)原因:提高哈希表的使用率,也有利于加快查找速度
#### 线性探查法
当一个槽被占用，找下一个可用的槽,每次的偏移量是1,直至找到没有被占用的槽位.
$$h(k, i) = (h^\prime(k) + i) % m$$, $$i = 0,1,...,m-1$$
$h^\prime(k)$ 是有冲突的逻辑下标

#### 平方/二次探查法
当一个槽被占用，找下一个可用的槽,每次的偏移量是i的平方(类似: $1^2$,$2^2$,$3^2$),直至找到没有被占用的槽位.
$$ h(k, i) = (h^\prime(k) + c_1 + c_2i^2) % m$$ , $$i=0,1,...,m-1 $$
 $c_1,c_2$是常数,$i^2$是偏移量
#### 双重哈希
采用另一个散列函数产生一个固定的偏移增量,之后与i进行结合,不是线性或者平方的偏移量
$ h(k,i) = (h_1(k) + ih_2(k)) % m $,, $$i=0,1,...,m-1 $$
$h_1(k)$是现有的逻辑下标值
$h_2(k)$是另外一个新的哈希函数
$ih_2(k)$作为偏移量
PS:  cpython 解释器采用的是平方/二次探查法解决hash冲突
## 哈希函数
选取标准:
    散列冲突越小越好,也就是每个key都尽可能分配到不同的槽位,所分配的槽位不受其他key的槽位影响.
例子:二次探查函数
## 装载因子/负载因子
   本质上就是 哈希表的使用率=8个元素/哈希表大小为9,一般来说,负载因子开始超过 0.8 的时候，就要新开辟空间并且重新进行散列了(重哈希)

## 重哈希--rehashing
   原理:开辟新一块2倍于当前大小的内存的新空间(不同python版本的cpython的分配策略不一样),将原有哈希表当中槽位不为空的数据,重新插入到新空间当中,重新计算逻辑下标的方式,插入方式和之前一样.

## 哈希表的ADT
data:
    槽位的状态,哈希表
API:
```
add(key, value)-->rehash
get(key, default)
removeNode(key)
```
PS:哈希表不一定就是为字典服务的,也可以为集合服务



